#ifndef  __FW_KM_H__
#define __FW_KM_H__

#include <stdbool.h>

/** 0: KM INITIALISE
    #BB00
    Initialize the Key Manager
    Action:
    Full initialization of the Key Manager (as during EMS). All Key Manager variables,
    buffers and indirections are initialized. The previous state of the Key Manager is lost.
    Entry conditions:
    No conditions.
    Exit conditions:
    AF,BC,DE and HL corrupt. All other registers preserved.
    Notes:
    The Key Manager indirection (KM TEST KEY) is set to its default routine.
    The key buffer is set up (to be empty).
    The expansion buffer is set up and the expansions are set to their default strings.
    The translation table are initialized to their default translations.
    The repeating key map is initialized to its default state.
    The repeat speeds are set to their default values.
    Shift and caps lock are turned off.
    The break event is disarmed.
    See Appendices II, III and IV for the default translation tables, repeating key table
    and expansion strings.
    This routine enables interrupts.
    Related entries:
    KM RESET
*/
void fw_km_initialise(void);

/** 1: KM RESET
    #BB03
    Reset the Key Manager.
    Action:
    Reinitializes the Key Manager indirections and buffers.
    Entry conditions:
    No conditions.
    Exit conditions:
    AF,BC,DE and HL corrupt. All other registers preserved.
    Notes:
    The Key Manager indirection (KM TEST KEY) is set to its default routine.
    The key buffer is set up (to be empty).
    The expansion buffer is set up and the expansions are set to their default strings (see
    Appendix IV).
    The break event is disarmed.
    All pending keys and characters are discarded.
    This routine enables interrupts.
    Related entries:
    KM DISARM BREAK
    KM EXP BUFFER
    KM INITIALISE
*/
void fw_km_reset(void);

/** 2: KM WAIT CHAR
    #BB06
    Wait for the next character from the keyboard.
    Action:
    Try to get a character from the key buffer or the current expansion string. This routine
    waits until a character is available if no character is immediately available.
    Entry conditions:
    No conditions.
    Exit conditions:
    Carry true. A contains the character. Other flags corrupt. All other registers preserved.
    Notes:
    The possible sources for generating the next character are, in the order that they are
    tested:
    The 'put back' character. The next character of an expansion string. The first character
    of an expansion string. A character from a key translation table.
    Expansion tokens found in the key translation table are expanded to their associated
    strings. Expansion tokens found in expansion strings are not expanded but are treated
    as characters.
    Related entries:
    KM CHAR RETURN
    KM READ CHAR
    KM WAIT KEY
*/
unsigned char fw_km_wait_char (void);

/** 3: KM READ CHAR
    #BB09
    Test if a character is available from the keyboard.
    Action: Try to get a character from the key buffer or the current expansion string.
    This routine does not wait for a character to become available if there is no character
    available immediately.
    Entry conditions:
    No conditions.
    Exit conditions:
    If there was a character available:
    Carry true. A contains the character.
    If there was no character available.
    Carry false. A corrupt.
    Always:
    Other flags corrupt. All other registers preserved.
    Notes:
    The possible sources for generating the next character are, in the order that they are
    tested:
    The 'put back' character. The next character of an expansion string. The first character
    of an expansion string. A character from a key translation table.
    Expansion tokens in the key translation table will be expanded to their associated
    strings. Expansion tokens found in expansion strings are not expanded but are treated
    as characters.
    This routine will always return a character if one is available. It is therefore possible
    to flush out the Key Manager buffers by calling KM READ CHAR repeatedly until it
    reports that no character is available.
    Related entries:
    KM CHAR RETURN
    KM FLUSH
    KM READ KEY
    KM WAIT CHAR
*/
unsigned char fw_km_read_char (void);

/** 4: KM CHAR RETURN #BB0C
    Return a single character to the keyboard for next time.
    Action:
    Save a character for the next call of KM READ CHAR or KM WAIT CHAR.
    Entry conditions:
    A contains the character to put back.
    Exit conditions:
    All registers and flags preserved.
    Notes:
    The 'put back' character will be returned before any other character is generated by
    the keyboard. It will not be expanded (or otherwise dealt with) but will be returned as
    it is. The 'put back' character need not have been read from the keyboard, it could be
    inserted by the user for some purpose.
    It is only possible to have one 'put back' character. If this routine is called twice
    without reading a character between these then the first (put back' will be lost.
    Furthermore, it is not possible to return character 255 (because this is used as the
    marker for no 'put back' character).
    Related entries:
    KM READ CHAR
    KM WAIT CHAR
*/
void fw_km_char_return (unsigned char c) __z88dk_fastcall;

unsigned char fw_km_wait_key (void);

/** Contrary to the firmware which sets carry to tell if return value is valid, C wrapper return 0 if no valid value. */
int fw_km_read_key (void);

void fw_km_disarm_break(void);
void fw_km_break_event(void);
void fw_km_flush(void);

#endif /* __FW_KM_H__ */
